"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LockManager = void 0;
const enums_1 = require("../enums");
/**
 * Manages lock renewal for BullMQ workers.
 * It periodically extends locks for active jobs to prevent them from being
 * considered stalled by other workers.
 */
class LockManager {
    constructor(worker, opts) {
        this.worker = worker;
        this.opts = opts;
        // Maps job ids with their timestamps
        this.trackedJobs = new Map();
        this.closed = false;
    }
    /**
     * Starts the lock manager timers for lock renewal.
     */
    start() {
        if (this.closed) {
            return;
        }
        // Start lock renewal timer if not disabled
        if (this.opts.lockRenewTime > 0) {
            this.startLockExtenderTimer();
        }
    }
    async extendLocks(jobIds) {
        await this.worker.trace(enums_1.SpanKind.INTERNAL, 'extendLocks', this.worker.name, async (span) => {
            span === null || span === void 0 ? void 0 : span.setAttributes({
                [enums_1.TelemetryAttributes.WorkerId]: this.opts.workerId,
                [enums_1.TelemetryAttributes.WorkerName]: this.opts.workerName,
                [enums_1.TelemetryAttributes.WorkerJobsToExtendLocks]: jobIds,
            });
            try {
                const jobTokens = jobIds.map(id => { var _a; return ((_a = this.trackedJobs.get(id)) === null || _a === void 0 ? void 0 : _a.token) || ''; });
                const erroredJobIds = await this.worker.extendJobLocks(jobIds, jobTokens, this.opts.lockDuration);
                if (erroredJobIds.length > 0) {
                    this.worker.emit('lockRenewalFailed', erroredJobIds);
                    for (const jobId of erroredJobIds) {
                        // TODO: Send signal to process function that the job has been lost.
                        this.worker.emit('error', new Error(`could not renew lock for job ${jobId}`));
                    }
                }
                const succeededJobIds = jobIds.filter(id => !erroredJobIds.includes(id));
                if (succeededJobIds.length > 0) {
                    this.worker.emit('locksRenewed', {
                        count: succeededJobIds.length,
                        jobIds: succeededJobIds,
                    });
                }
            }
            catch (err) {
                this.worker.emit('error', err);
            }
        });
    }
    startLockExtenderTimer() {
        clearTimeout(this.lockRenewalTimer);
        if (!this.closed) {
            this.lockRenewalTimer = setTimeout(async () => {
                // Get all the jobs whose locks expire in less than 1/2 of the lockRenewTime
                const now = Date.now();
                const jobsToExtend = [];
                for (const jobId of this.trackedJobs.keys()) {
                    const { ts, token } = this.trackedJobs.get(jobId);
                    if (!ts) {
                        this.trackedJobs.set(jobId, { token, ts: now });
                        continue;
                    }
                    if (ts + this.opts.lockRenewTime / 2 < now) {
                        this.trackedJobs.set(jobId, { token, ts: now });
                        jobsToExtend.push(jobId);
                    }
                }
                if (jobsToExtend.length) {
                    await this.extendLocks(jobsToExtend);
                }
                this.startLockExtenderTimer();
            }, this.opts.lockRenewTime / 2);
        }
    }
    /**
     * Stops the lock manager and clears all timers.
     */
    async close() {
        if (this.closed) {
            return;
        }
        this.closed = true;
        if (this.lockRenewalTimer) {
            clearTimeout(this.lockRenewalTimer);
            this.lockRenewalTimer = undefined;
        }
        this.trackedJobs.clear();
    }
    /**
     * Adds a job to be tracked for lock renewal.
     */
    trackJob(jobId, token, ts) {
        if (!this.closed && jobId) {
            this.trackedJobs.set(jobId, { token, ts });
        }
    }
    /**
     * Removes a job from lock renewal tracking.
     */
    untrackJob(jobId) {
        this.trackedJobs.delete(jobId);
    }
    /**
     * Gets the number of jobs currently being tracked.
     */
    getActiveJobCount() {
        return this.trackedJobs.size;
    }
    /**
     * Checks if the lock manager is running.
     */
    isRunning() {
        return !this.closed && this.lockRenewalTimer !== undefined;
    }
}
exports.LockManager = LockManager;
//# sourceMappingURL=lock-manager.js.map